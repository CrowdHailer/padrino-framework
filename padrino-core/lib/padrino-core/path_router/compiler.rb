module Padrino
  module PathRouter
    #
    # High performance engine for finding all routes which are matched with pattern
    #
    class Compiler
      # All regexps generated by recursive compiler
      attr_reader :regexps

      ##
      # Constructs an instance of Padrino::PathRouter::Compiler
      #
      def initialize(routes)
        @routes = routes
      end
  
      ##
      # Compiles all routes into regexps.
      #
      def compile!
        return if compiled?
        @regexps = @routes.map.with_index do |route, index|
          route.index = index
          /(?<_#{index}>#{route.matcher.to_regexp})/
        end
        @regexps = recursive_compile(@regexps)
        @compiled = true
      end

      ##
      # Returns true if all routes has been compiled.
      #
      def compiled?
        !!@compiled
      end
  
      def find_by_request(request, &block)
        run_through_regexps do |offset|
          loop.with_object([]) do |_, candidacies|
            return candidacies unless @regexps[offset] === request.path_info || @regexps[offset] === request.path_info[0..-2]
            route = @routes[offset..-1].detect{ |route| Regexp.last_match("_#{route.index}") }
            yield(route, route.params_for(request.path_info, request.params), offset) if route.verb == request.request_method.downcase.to_sym
            candidacies << route
            offset = route.index.next
          end
        end
      end

      def find_by_pattern(pattern)
        run_through_regexps do |offset|
          loop.with_object([]) do |_, candidacies|
            return candidacies unless @regexps[offset] === pattern || @regexps[offset] === pattern[0..-2]
            route = @routes[offset..-1].detect{ |route| Regexp.last_match("_#{route.index}") }
            candidacies << route
            offset = route.index.next
          end
        end
      end
  
      private

      def run_through_regexps
        compile! unless compiled?
        yield 0
      end

      ##
      # Compiles routes into regexp recursively.
      #
      def recursive_compile(regexps, paths = [])
        return paths if regexps.length.zero?
        paths << Regexp.union(regexps)
        regexps.shift
        recursive_compile(regexps, paths)
      end

      ##
      # Parses request and then returns an array.
      # 
      def parse_request(request)
        if request.is_a?(Hash)
          [request['PATH_INFO'], request['REQUEST_METHOD'].downcase.to_sym, {}]
        else
          [request.path_info, request.request_method.downcase.to_sym, request.params]
        end
      end
  
      ##
      # Raises an exception.
      #
      def raise_exception(error_code, options = {})
        raise ->(error_code) {
          case error_code
          when 400
            BadRequest
          when 404
            NotFound
          when 405
            MethodNotAllowed.new(options[:verbs])
          end
        }.call(error_code)
      end
    end
  end
end
